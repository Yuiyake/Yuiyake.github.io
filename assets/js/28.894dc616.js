(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{679:function(a,t,e){"use strict";e.r(t);var s=e(4),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("#概念及理解")]),a._v(" "),e("ul",[e("li",[a._v("这些概念用于描述对象的类型；由于java是面向对象的语言；程序的世界就是各个对象之间的“交互”；在交互的工程中会存在多个层次，每个层次中所拥有（关注）的内容都是不一样的；")])]),a._v(" "),e("h2",{attrs:{id:"这些是具体的例子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这些是具体的例子"}},[a._v("#")]),a._v(" 这些是具体的例子")]),a._v(" "),e("h2",{attrs:{id:"po-persistant-object-持久对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#po-persistant-object-持久对象"}},[a._v("#")]),a._v(" PO(Persistant Object) 持久对象")]),a._v(" "),e("p",[a._v("用于表示数据库中的一条记录映射成的 java 对象。PO 仅仅用于表示数据，没有任何数据操作。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。\n可以理解是一个PO就是数据库中的一条记录；可以理解某个事务依赖的原始数据；好处是可以将一条记录最为一个对象处理，可以方便转化为其他对象")]),a._v(" "),e("hr"),a._v(" "),e("h2",{attrs:{id:"bo-business-object-业务对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bo-business-object-业务对象"}},[a._v("#")]),a._v(" BO(Business Object) 业务对象")]),a._v(" "),e("p",[a._v("封装对象、复杂对象，里面可能包含多个类\n主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。")]),a._v(" "),e("p",[a._v("用于表示一个业务对象。BO 包括了业务逻辑，常常封装了对 DAO、RPC 等的调用，可以进行 PO 与 VO/DTO 之间的转换。BO 通常位于业务层，要区别于直接对外提供服务的服务层：BO 提供了基本业务单元的基本业务操作，在设计上属于被服务层业务流程调用的对象，一个业务流程可能需要调用多个 BO 来完成。")]),a._v(" "),e("p",[a._v("比如一个简历，有教育经历、工作经历、社会关系等等。\n我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。\n建立一个对应简历的BO对象处理简历，每个BO包含这些PO。\n这样处理业务逻辑时，我们就可以针对BO去处理。")]),a._v(" "),e("hr"),a._v(" "),e("h2",{attrs:{id:"vo-value-object-表现对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vo-value-object-表现对象"}},[a._v("#")]),a._v(" VO(Value Object) 表现对象")]),a._v(" "),e("p",[a._v("前端界面展示；value object值对象；ViewObject表现层对象；主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值；对于Android而言即是activity或view中的数据元素。")]),a._v(" "),e("p",[a._v("用于表示一个与前端进行交互的 java 对象。有的朋友也许有疑问，这里可不可以使用 PO 传递数据？实际上，这里的 VO 只包含前端需要展示的数据即可，对于前端不需要的数据，比如数据创建和修改的时间等字段，出于减少传输数据量大小和保护数据库结构不外泄的目的，不应该在 VO 中体现出来。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。")]),a._v(" "),e("hr"),a._v(" "),e("h2",{attrs:{id:"dto-data-transfer-object-数据传输对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dto-data-transfer-object-数据传输对象"}},[a._v("#")]),a._v(" DTO(Data Transfer Object) 数据传输对象")]),a._v(" "),e("p",[a._v("前端调用时传输；也可理解成“上层”调用时传输;\n比如我们一张表有100个字段，那么对应的PO就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO.")]),a._v(" "),e("p",[a._v("用于表示一个数据传输对象。DTO 通常用于不同服务或服务不同分层之间的数据传输。DTO 与 VO 概念相似，并且通常情况下字段也基本一致。但 DTO 与 VO 又有一些不同，这个不同主要是设计理念上的，比如 API 服务需要使用的 DTO 就可能与 VO 存在差异。通常遵守 Java Bean 的规范，拥有 getter/setter 方法")]),a._v(" "),e("hr"),a._v(" "),e("h2",{attrs:{id:"dao-data-access-object-数据访问对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dao-data-access-object-数据访问对象"}},[a._v("#")]),a._v(" DAO(Data access object) 数据访问对象")]),a._v(" "),e("p",[a._v("这个大家最熟悉，和上面几个O区别最大，基本没有互相转化的可能性和必要.，主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO；")]),a._v(" "),e("p",[a._v("用于表示一个数据访问对象。使用 DAO 访问数据库，包括插入、更新、删除、查询等操作，与 PO 一起使用。DAO 一般在持久层，完全封装数据库操作，对外暴露的方法使得上层应用不需要关注数据库相关的任何信息。")]),a._v(" "),e("hr"),a._v(" "),e("h2",{attrs:{id:"pojo-plain-ordinary-java-object-简单java对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pojo-plain-ordinary-java-object-简单java对象"}},[a._v("#")]),a._v(" POJO(Plain ordinary java object) 简单java对象")]),a._v(" "),e("p",[a._v("一个POJO持久化以后就是PO；直接用它传递、传递过程中就是DTO；直接用来对应表示层就是VO。")])])}),[],!1,null,null,null);t.default=r.exports}}]);